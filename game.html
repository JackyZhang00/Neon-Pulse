<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Neon Pulse</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: white; font-family: 'Segoe UI', sans-serif; user-select: none; }
        
        /* --- ÂºÄÂ±èÁïåÈù¢Ê†∑Âºè --- */
        #splash-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at center, #1a1a2e 0%, #000 100%);
            z-index: 9999; display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            transition: opacity 0.5s ease, transform 0.5s ease;
        }
        
        .splash-grid {
            position: absolute; width: 200%; height: 200%; top: -50%; left: -50%;
            background-image: 
                linear-gradient(rgba(0, 255, 255, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 255, 0.1) 1px, transparent 1px);
            background-size: 50px 50px;
            transform: perspective(500px) rotateX(60deg);
            animation: grid-move 10s linear infinite;
            pointer-events: none;
        }

        @keyframes grid-move { 0% { transform: perspective(500px) rotateX(60deg) translateY(0); } 100% { transform: perspective(500px) rotateX(60deg) translateY(50px); } }

        .kanban-container {
            position: absolute; bottom: 0; right: 10%; height: 85%; width: auto;
            pointer-events: none;
            animation: breathe 3s ease-in-out infinite;
            filter: drop-shadow(0 0 20px rgba(0, 255, 255, 0.3));
            transition: filter 0.3s;
        }

        .kanban-img {
            height: 100%; width: auto; object-fit: contain;
            content: url('nana/cover.png'); 
            mask-image: linear-gradient(to top, transparent 0%, black 20%);
            -webkit-mask-image: linear-gradient(to top, transparent 0%, black 20%);
        }
        
        @keyframes breathe { 0%, 100% { transform: translateY(0) scale(1); } 50% { transform: translateY(-10px) scale(1.01); } }

        .speech-bubble {
            position: absolute; bottom: 85%; right: 25%;
            background: rgba(255, 255, 255, 0.9); color: #000;
            padding: 15px 25px; border-radius: 20px 20px 0 20px;
            font-weight: bold; font-size: 18px;
            box-shadow: 0 0 15px #0ff;
            opacity: 0; transform: translateY(20px);
            animation: pop-in 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards 0.5s;
        }
        .speech-bubble::after {
            content: ''; position: absolute; bottom: -10px; right: 0;
            border-width: 10px 10px 0 0; border-style: solid;
            border-color: rgba(255, 255, 255, 0.9) transparent transparent transparent;
        }

        .splash-content {
            z-index: 2; text-align: center; position: relative;
            margin-right: 20%; 
        }

        .splash-title {
            font-size: 100px; font-weight: 900; color: #fff;
            text-transform: uppercase; font-style: italic;
            text-shadow: 4px 4px 0px #f05, -4px -4px 0px #0ff;
            letter-spacing: -5px; margin: 0;
            animation: glitch-skew 3s infinite linear alternate-reverse;
        }

        .splash-subtitle {
            font-size: 24px; color: #0ff; letter-spacing: 10px;
            margin-bottom: 50px; text-shadow: 0 0 10px #0ff;
        }

        .click-hint {
            font-size: 20px; color: #aaa; border: 1px solid #555;
            padding: 10px 30px; border-radius: 30px;
            background: rgba(0,0,0,0.5); cursor: pointer;
            transition: all 0.2s; animation: pulse-opacity 1.5s infinite;
        }
        .click-hint:hover { background: #fff; color: #000; box-shadow: 0 0 20px #fff; }

        @keyframes pulse-opacity { 0%, 100% { opacity: 0.5; } 50% { opacity: 1; } }
        @keyframes pop-in { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        
        @keyframes glitch-skew {
            0% { transform: skew(0deg); }
            20% { transform: skew(0deg); }
            22% { transform: skew(10deg); }
            24% { transform: skew(-10deg); }
            26% { transform: skew(0deg); }
            100% { transform: skew(0deg); }
        }

        /* --- Ê∏∏ÊàèÂü∫Á°ÄÊ†∑Âºè --- */
        #bg-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-size: cover; background-position: center;
            opacity: 0.3; filter: blur(8px) brightness(0.5); z-index: 0;
            transition: all 0.1s ease;
        }

        canvas { display: block; position: relative; z-index: 1; }
        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 10;
            backdrop-filter: blur(10px);
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
        }

        #countdown-overlay {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 30; background: rgba(0,0,0,0.3);
            font-size: 150px; font-weight: 900; color: #fff;
            text-shadow: 0 0 30px #0ff;
            align-items: center; justify-content: center;
        }

        #loading-overlay {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 50; background: rgba(0,0,0,0.9);
            flex-direction: column; align-items: center; justify-content: center;
        }
        .loading-spinner {
            width: 50px; height: 50px; border: 5px solid #333; border-top: 5px solid #0ff;
            border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        #hud { position: absolute; width: 100%; height: 100%; pointer-events: none; z-index: 5; display: none; }
        #score-display { position: absolute; top: 20px; left: 20px; font-size: 40px; font-weight: 900; }
        
        #auto-indicator {
            position: absolute; top: 65px; left: 24px; 
            font-size: 14px; color: #00ccff; font-weight: bold; letter-spacing: 2px;
            border: 1px solid #00ccff; padding: 2px 6px; border-radius: 4px;
            display: none; box-shadow: 0 0 10px rgba(0,204,255,0.3);
        }

        #combo-display { position: absolute; top: 90px; left: 20px; font-size: 30px; color: #ffcc00; font-weight: bold; opacity: 0; transition: transform 0.1s; }
        #song-info-hud { position: absolute; top: 20px; right: 20px; text-align: right; }
        
        /* --- ÂàÜÊï∞Êù°Ê†∑Âºè --- */
        #score-bar-container {
            position: absolute; right: 30px; top: 100px; bottom: 50px; width: 15px;
            background: rgba(20, 20, 20, 0.6); border: 1px solid #444; border-radius: 8px;
            overflow: visible;
        }
        #score-bar-fill {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 0%;
            background: linear-gradient(to top, #00ccff, #00ffaa);
            border-radius: 8px;
            transition: height 0.1s linear, background 0.3s;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }
        
        @keyframes rainbow-flow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        @keyframes bar-pulse {
            0% { box-shadow: 0 0 15px #ff0055, 0 0 30px rgba(255, 0, 85, 0.5); }
            50% { box-shadow: 0 0 25px #ff0055, 0 0 50px rgba(255, 200, 0, 0.8); }
            100% { box-shadow: 0 0 15px #ff0055, 0 0 30px rgba(255, 0, 85, 0.5); }
        }

        .score-bar-cleared {
            background: linear-gradient(0deg, #ff0055, #ffcc00, #00ffaa, #00ccff, #d600ff, #ff0055) !important;
            background-size: 100% 400% !important;
            animation: rainbow-flow 3s linear infinite, bar-pulse 1s ease-in-out infinite !important;
            border: 1px solid rgba(255,255,255,0.8);
        }

        #score-bar-marker {
            position: absolute; left: -5px; width: 25px; height: 2px;
            background: #aaa; z-index: 10;
            box-shadow: 0 0 5px #fff;
            transition: background 0.3s;
        }
        #score-bar-marker.marker-passed {
            background: #fff; box-shadow: 0 0 10px #ff0055;
        }
        #score-bar-marker::after {
            content: "CLEAR"; position: absolute; right: 30px; top: -10px;
            font-size: 10px; color: #aaa; font-weight: bold; font-family: monospace;
            transition: color 0.3s;
        }
        #score-bar-marker.marker-passed::after { color: #fff; text-shadow: 0 0 5px #ff0055; }
        
        /* --- ÁªìÁÆóÂç∞Á´†Ê†∑Âºè --- */
        .stamp-normal {
            font-size: 30px; font-weight: bold; 
            border: 3px solid currentColor; display: inline-block; padding: 5px 15px; 
            transform: rotate(-10deg);
        }
        .stamp-critical {
            font-size: 50px; font-weight: 900; font-family: 'Segoe UI', sans-serif;
            padding: 10px 40px; border: 5px solid rgba(255,255,255,0.8); border-radius: 12px;
            text-transform: uppercase; display: inline-block;
            background: linear-gradient(to right, #ff0000, #ff8800, #ffff00, #00ff00, #00ffff, #0000ff, #ff00ff, #ff0000);
            background-size: 200% auto;
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            animation: stamp-shine 2s linear infinite, stamp-pulse 0.8s ease-in-out infinite alternate, stamp-rotate-wobble 3s ease-in-out infinite;
        }
        .stamp-auto {
            font-size: 40px; font-weight: bold; 
            border: 4px solid #00ccff; color: #00ccff;
            display: inline-block; padding: 10px 30px; 
            transform: rotate(-5deg); letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(0,204,255,0.5);
            box-shadow: 0 0 15px rgba(0,204,255,0.3), inset 0 0 15px rgba(0,204,255,0.3);
        }

        @keyframes stamp-shine { to { background-position: 200% center; } }
        @keyframes stamp-pulse {
            from { box-shadow: 0 0 20px rgba(255,0,0,0.5), inset 0 0 10px rgba(255,0,0,0.5); border-color: #ff0055; transform: rotate(-10deg) scale(1); }
            to { box-shadow: 0 0 50px rgba(0,255,255,0.8), inset 0 0 30px rgba(0,255,255,0.5); border-color: #00ccff; transform: rotate(-10deg) scale(1.1); }
        }
        @keyframes stamp-rotate-wobble {
            0%, 100% { transform: rotate(-10deg) scale(1); }
            50% { transform: rotate(-12deg) scale(1.05); }
        }

        /* --- ÈÄâÊ≠åÁïåÈù¢ --- */
        #song-select-screen { display: flex; flex-direction: column; padding: 30px; box-sizing: border-box; }
        #category-bar { height: 50px; display: flex; gap: 10px; margin-bottom: 20px; overflow-x: auto; align-items: center; border-bottom: 1px solid #444; padding-bottom: 10px; }
        .tag-btn { padding: 5px 15px; border-radius: 20px; border: 1px solid #666; background: transparent; color: #aaa; cursor: pointer; white-space: nowrap; }
        .tag-btn.active { background: #fff; color: #000; border-color: #fff; font-weight: bold; }
        
        .content-wrapper { display: flex; flex: 1; overflow: hidden; gap: 40px; width: 100%; }
        .song-list-panel { flex: 1; overflow-y: auto; display: flex; flex-direction: column; gap: 8px; padding-right: 10px; border-right: 1px solid #333; }
        .song-item { padding: 15px; background: rgba(255,255,255,0.05); cursor: pointer; border-left: 4px solid transparent; border-radius: 4px; }
        .song-item.selected { background: linear-gradient(90deg, rgba(0,255,255,0.2), transparent); border-left: 4px solid #0ff; }
        .song-info-panel { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .cover-art { width: 300px; height: 300px; object-fit: cover; border-radius: 8px; border: 2px solid #555; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        
        .diff-selector { display: flex; gap: 10px; margin: 20px 0; }
        .diff-btn { padding: 8px 20px; border: 1px solid #666; background: transparent; color: #888; cursor: pointer; border-radius: 20px; font-weight: bold; transition: all 0.2s; }
        .diff-btn.disabled { opacity: 0.2; cursor: not-allowed; border-color: #333; background: #111; color: #444; pointer-events: none; }
        
        .diff-btn[data-diff="easy"].active { background: #00ccff; border-color: #00ccff; box-shadow: 0 0 15px #00ccff; color: #000; }
        .diff-btn[data-diff="normal"].active { background: #00ff00; border-color: #00ff00; box-shadow: 0 0 15px #00ff00; color: #000; }
        .diff-btn[data-diff="hard"].active { background: #ffcc00; border-color: #ffcc00; box-shadow: 0 0 15px #ffcc00; color: #000; }
        .diff-btn[data-diff="expert"].active { background: #ff0000; border-color: #ff0000; box-shadow: 0 0 15px #ff0000; color: #fff; }

        .main-btn { padding: 15px 50px; font-size: 20px; background: #fff; border: none; border-radius: 50px; cursor: pointer; font-weight: bold; transition: 0.2s; margin-top: 15px; }
        .main-btn:hover { background: #0ff; transform: scale(1.05); }

        /* --- ÂéÜÂè≤ÊúÄ‰Ω≥ÊàêÁª©Â±ïÁ§∫Ê†∑Âºè --- */
        #best-record-box {
            background: rgba(0,0,0,0.4); border: 1px solid #444; border-radius: 8px;
            padding: 10px 25px; margin: 10px 0;
            display: flex; flex-direction: column; align-items: center;
            min-width: 200px;
        }
        .record-label { font-size: 12px; color: #888; letter-spacing: 2px; margin-bottom: 2px; }
        .record-val { font-size: 24px; font-weight: 900; font-family: monospace; color: #fff; text-shadow: 0 0 5px #fff; }
        .record-badge { 
            font-size: 12px; font-weight: bold; padding: 2px 8px; border-radius: 4px; margin-top: 5px; 
            letter-spacing: 1px;
        }
        .badge-none { display: none; }
        .badge-clear { border: 1px solid #aaa; color: #aaa; }
        .badge-fc { border: 1px solid #ffcc00; color: #ffcc00; background: rgba(255, 204, 0, 0.1); box-shadow: 0 0 10px rgba(255,204,0,0.2); }
        .badge-ap { border: 1px solid #00ccff; color: #00ccff; background: rgba(0, 204, 255, 0.1); box-shadow: 0 0 10px rgba(0,204,255,0.2); }
        .badge-ac { 
            border: 1px solid #d600ff; 
            background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00, #00ffff, #0000ff, #ff00ff);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            font-weight: 900;
        }

        /* --- ËÆæÁΩÆËèúÂçïÊ†∑Âºè --- */
        #settings-btn {
            position: absolute; top: 30px; right: 30px; z-index: 20;
            background: transparent; border: 1px solid #666; color: #aaa;
            padding: 8px 15px; border-radius: 20px; cursor: pointer;
            font-weight: bold; transition: all 0.3s;
            display: flex; align-items: center; gap: 5px;
        }
        #settings-btn:hover { border-color: #0ff; color: #0ff; background: rgba(0,255,255,0.1); }

        /* „ÄêNEW„ÄëÊî∂‰ª∂ÁÆ±ÊåâÈíÆÊ†∑Âºè */
        #mailbox-btn {
            position: absolute; top: 30px; right: 160px; z-index: 20;
            background: transparent; border: 1px solid #666; color: #aaa;
            padding: 8px 15px; border-radius: 20px; cursor: pointer;
            font-weight: bold; transition: all 0.3s;
            display: flex; align-items: center; gap: 5px;
        }
        #mailbox-btn:hover { border-color: #f05; color: #f05; background: rgba(255,0,85,0.1); }
        .badge-notification {
            width: 10px; height: 10px; background: #f05; border-radius: 50%;
            position: absolute; top: 0; right: 0; box-shadow: 0 0 5px #f05;
            display: none; animation: pulse-badge 1s infinite;
        }

        #settings-overlay {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); z-index: 80; backdrop-filter: blur(5px);
            align-items: center; justify-content: center;
        }

        .settings-panel {
            background: #1a1a1a; padding: 40px; border-radius: 12px; border: 1px solid #444;
            width: 450px; max-width: 90%; box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }

        .settings-header {
            font-size: 24px; font-weight: 900; color: #fff; border-bottom: 1px solid #333;
            padding-bottom: 15px; margin-bottom: 20px; text-align: center; letter-spacing: 2px;
        }

        .setting-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; font-size: 16px; color: #ccc; }
        .setting-row input[type="range"] { flex: 1; margin: 0 15px; accent-color: #0ff; }
        .setting-row select, .setting-row input[type="number"] { background: #333; border: 1px solid #555; color: white; padding: 5px 10px; border-radius: 4px; font-family: inherit; }
        .setting-row input[type="checkbox"] { width: 24px; height: 24px; cursor: pointer; accent-color: #0ff; }
        .setting-group-title { color: #0ff; font-size: 14px; font-weight: bold; margin-top: 20px; margin-bottom: 10px; border-left: 3px solid #0ff; padding-left: 10px; }

        /* --- ÁªìÁÆóÁïåÈù¢ --- */
        #result-card { background: #222; padding: 40px; border-radius: 12px; border: 1px solid #444; text-align: center; min-width: 500px; position: relative; }
        .grade-big { font-size: 100px; font-weight: 900; margin: 10px 0; }
        .failed-text { color: #f05; font-size: 30px; font-weight: bold; margin-top: 10px; display: none; }
        
        .stat-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 10px;
            background: rgba(0,0,0,0.3); padding: 20px; border-radius: 8px;
            margin: 20px 0; text-align: left; font-family: monospace; font-size: 18px;
        }
        .stat-row { display: flex; justify-content: space-between; }
        .stat-label { color: #aaa; }
        .stat-val { font-weight: bold; }

        .new-record-badge {
            position: absolute;
            top: 20%; right: -25px;
            transform: rotate(15deg);
            font-size: 20px; font-weight: 900; color: #fff700;
            background: linear-gradient(45deg, #ff0055, #ff5500);
            padding: 8px 20px;
            border: 2px solid #fff; border-radius: 8px;
            box-shadow: 0 0 20px rgba(255, 247, 0, 0.6);
            animation: pulse-badge 0.6s infinite alternate;
            z-index: 20; display: none;
            letter-spacing: 2px;
        }
        @keyframes pulse-badge {
            from { transform: rotate(15deg) scale(1); box-shadow: 0 0 20px rgba(255, 247, 0, 0.6); }
            to { transform: rotate(15deg) scale(1.1); box-shadow: 0 0 40px rgba(255, 247, 0, 1); }
        }
        
        /* --- Êõ¥Êñ∞Êó•Âøó --- */
        #update-box {
            background: #1a1a1a; padding: 40px; border-radius: 12px; border: 1px solid #0ff;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.15); max-width: 600px; width: 85%; color: #eee;
        }
        .update-header { text-align: center; font-size: 24px; font-weight: 900; color: #0ff; margin-bottom: 20px; }
        .update-content { margin-bottom: 30px; font-size: 16px; max-height: 300px; overflow-y: auto; }
        .update-tag { display: inline-block; background: rgba(0, 255, 255, 0.2); color: #0ff; padding: 2px 8px; border-radius: 4px; font-size: 12px; margin-right: 8px; font-weight: bold; }
        .update-list-item { margin-bottom: 10px; border-bottom: 1px solid #333; padding-bottom: 10px; }

        /* --- Ê†°ÂáÜÁïåÈù¢ --- */
        #calibration-overlay {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #111; z-index: 60; flex-direction: column; align-items: center; justify-content: center; user-select: none;
        }
        .calib-visual-beat {
            width: 100px; height: 100px; background: #333; border-radius: 50%;
            box-shadow: 0 0 0px #333; transition: transform 0.1s, background 0.1s, box-shadow 0.1s;
            margin-bottom: 40px; display: flex; align-items: center; justify-content: center;
            font-size: 30px; font-weight: bold; color: rgba(255,255,255,0.2);
        }
        .calib-visual-beat.beat-active { transform: scale(1.2); background: #fff; box-shadow: 0 0 30px #fff; }
        .calib-visual-beat.tap-feedback { border: 2px solid #0ff; background: transparent; color: #0ff; }
        .calib-progress { width: 300px; height: 4px; background: #333; margin: 20px 0; border-radius: 2px; }
        .calib-progress-bar { height: 100%; background: #0ff; width: 0%; transition: width 0.2s; box-shadow: 0 0 10px #0ff; }
        .calib-instruction { color: #888; margin-bottom: 20px; text-align: center; line-height: 1.6; }
        .calib-result-text { font-size: 24px; color: #0ff; font-weight: bold; margin-top: 10px; }

        /* „ÄêNEW„ÄëÊî∂‰ª∂ÁÆ±ÁïåÈù¢Ê†∑Âºè */
        #mailbox-overlay {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 90; backdrop-filter: blur(8px);
            align-items: center; justify-content: center;
        }
        .mailbox-panel {
            background: #111; border: 1px solid #444; width: 800px; height: 500px;
            display: flex; border-radius: 8px; box-shadow: 0 0 40px rgba(0,0,0,0.8);
            overflow: hidden;
        }
        .mail-list {
            width: 300px; background: #1a1a1a; border-right: 1px solid #333;
            overflow-y: auto; display: flex; flex-direction: column;
        }
        .mail-item {
            padding: 15px; border-bottom: 1px solid #333; cursor: pointer;
            transition: background 0.2s; position: relative;
        }
        .mail-item:hover { background: #222; }
        .mail-item.active { background: #2a2a2a; border-left: 3px solid #f05; }
        .mail-item-title { font-weight: bold; margin-bottom: 5px; color: #eee; }
        .mail-item-sender { font-size: 12px; color: #888; }
        .mail-item.unread::after {
            content: 'NEW'; position: absolute; top: 15px; right: 15px;
            background: #f05; color: #fff; font-size: 10px; padding: 2px 5px;
            border-radius: 4px; font-weight: bold;
        }
        .mail-content-area {
            flex: 1; padding: 30px; display: flex; flex-direction: column; position: relative;
            background: 
                radial-gradient(circle at top right, rgba(255,0,85,0.05) 0%, transparent 40%),
                linear-gradient(to bottom, #111 0%, #0d0d0d 100%);
        }
        .mail-detail-header { border-bottom: 1px solid #333; padding-bottom: 20px; margin-bottom: 20px; }
        .mail-detail-title { font-size: 28px; font-weight: 900; color: #fff; margin-bottom: 10px; }
        .mail-detail-meta { color: #666; font-size: 14px; display: flex; justify-content: space-between; }
        .mail-body {
            font-size: 16px; line-height: 1.6; color: #ccc; white-space: pre-wrap; flex: 1; overflow-y: auto;
        }
        .btn-close-mail {
            position: absolute; top: 10px; right: 10px; background: transparent; border: none;
            color: #666; font-size: 24px; cursor: pointer;
        }
        .btn-close-mail:hover { color: #fff; }

    </style>
</head>
<body>

<div id="splash-screen" onclick="enterGame()">
    <div class="splash-grid"></div>
    <div class="kanban-container">
        <img class="kanban-img" src="nana/cover.png" alt="Kanban">
    </div>
    <div class="speech-bubble">ÂêåÊ≠•‰ø°Âè∑Êé•ÈÄöÔºÅ‰Ω†Áªà‰∫éÊù•Âï¶ÔºÅ‰ªäÂ§©‰πüË¶Å‰∏ÄËµ∑ÊääËäÇÂ•èÁÇπÁáÉÂêóÔºü‚ú®</div>
    <div class="splash-content">
        <h1 class="splash-title">NEON PULSE</h1>
        <div class="splash-subtitle">CYBER RHYTHM ACTION</div>
        <div class="click-hint">>> CLICK TO START <<</div>
    </div>
</div>

<div id="bg-layer"></div>
<div id="progress-bar" style="position:absolute; top:0; left:0; height:5px; background:#0ff; z-index:20; width:0%;"></div>

<div id="countdown-overlay" style="display:none;">5</div>

<div id="loading-overlay">
    <div class="loading-spinner"></div>
    <div style="font-size: 20px; letter-spacing: 2px; font-weight: bold;">LOADING DATA...</div>
    <div id="loading-text" style="margin-top:10px; color:#888; font-size:14px;">Please wait</div>
</div>

<div id="calibration-overlay">
    <h2 style="color:#fff; letter-spacing:4px; margin-bottom:10px;">AUDIO SYNC</h2>
    <div class="calib-instruction" id="calib-step-1">
        ËØ∑Ë∑üÈöèËäÇÂ•èÔºåÂú®Âê¨Âà∞ <strong>ÈáçÈü≥</strong> Êó∂Êåâ‰∏ãÁ©∫Ê†ºÊàñÁÇπÂáªÂ±èÂπï„ÄÇ<br>
        ÂÖ±ÈúÄÊï≤Âáª 8 Ê¨°ÔºåÁ≥ªÁªüÂ∞ÜËá™Âä®ËÆ°ÁÆóÂª∂Ëøü„ÄÇ
    </div>
    <div id="calib-beat-circle" class="calib-visual-beat">‚ô™</div>
    <div class="calib-progress"><div id="calib-progress-bar" class="calib-progress-bar"></div></div>
    <div id="calib-status" style="color:#aaa; font-family:monospace;">Waiting...</div>
    <div id="calib-result" class="calib-result-text" style="display:none;">0 ms</div>
    <div style="margin-top:40px; display:flex; gap:20px;">
        <button class="main-btn" onclick="stopCalibration()" style="padding:10px 30px; font-size:16px; background:#333; color:#aaa;">CANCEL</button>
        <button id="calib-apply-btn" class="main-btn" onclick="applyCalibration()" style="padding:10px 30px; font-size:16px; display:none;">APPLY & SAVE</button>
    </div>
</div>

<div id="hud">
    <div id="score-display">0000000</div>
    <div id="auto-indicator">[ AUTOMATION ACTIVE ]</div>
    <div id="combo-display">COMBO 0</div>
    <div id="song-info-hud">
        <div id="hud-title" style="font-weight:bold; font-size:20px;">Title</div>
        <div id="hud-detail" style="color:#aaa;">Artist</div>
    </div>
    
    <div id="score-bar-container">
        <div id="score-bar-fill"></div>
        <div id="score-bar-marker"></div>
    </div>

    <button onclick="pauseGame()" style="pointer-events:auto; position:absolute; top:20px; left:50%; transform:translateX(-50%); background:transparent; border:1px solid #fff; color:#fff; padding:5px 15px; cursor:pointer;">PAUSE (ESC)</button>
</div>

<!-- ÊöÇÂÅúËèúÂçï -->
<div id="pause-menu" class="overlay" style="display:none;">
    <h1 style="color:#fff;">PAUSED</h1>
    <button class="main-btn" onclick="startResumeCountdown()">RESUME</button>
    <button class="main-btn" onclick="retryGame()" style="margin-top:20px; background:#00ccff; color:black;">RETRY</button>
    <button class="main-btn" onclick="backToMenu()" style="margin-top:20px; background:#f05; color:white;">EXIT</button>
</div>

<!-- „ÄêNEW„ÄëÊî∂‰ª∂ÁÆ±ÂºπÁ™ó -->
<div id="mailbox-overlay">
    <div class="mailbox-panel">
        <div class="mail-list" id="mail-list-container">
            <!-- ÈÇÆ‰ª∂ÂàóË°®Â∞ÜÂú®ËøôÈáåÂä®ÊÄÅÁîüÊàê -->
        </div>
        <div class="mail-content-area">
            <button class="btn-close-mail" onclick="closeMailbox()">√ó</button>
            <div id="mail-detail-view" style="display:none; height:100%; flex-direction:column;">
                <div class="mail-detail-header">
                    <div class="mail-detail-title" id="mail-view-title">Title</div>
                    <div class="mail-detail-meta">
                        <span id="mail-view-sender">From: Sender</span>
                        <span id="mail-view-date">Date</span>
                    </div>
                </div>
                <div class="mail-body" id="mail-view-content">Content...</div>
            </div>
            <div id="mail-empty-state" style="display:flex; height:100%; align-items:center; justify-content:center; color:#444;">
                <div>SELECT A MAIL TO READ</div>
            </div>
        </div>
    </div>
</div>

<div id="settings-overlay">
    <div class="settings-panel">
        <div class="settings-header">SETTINGS</div>
        
        <div class="setting-group-title">GAMEPLAY</div>
        <div class="setting-row">
            <span>Note Speed (ÊµÅÈÄü)</span>
            <input type="range" id="speed-input" min="1" max="8" step="0.1" value="2.0">
            <span id="speed-val" style="width:35px; text-align:right;">2.0</span>
        </div>
        <div class="setting-row">
            <span>Input Mode (ÊåâÈîÆ)</span>
            <select id="input-mode-select">
                <option value="arrow">Arrow Keys (‚Üë‚Üí‚Üì‚Üê)</option>
                <option value="wasd">WASD (W D S A)</option>
            </select>
        </div>
        <div class="setting-row">
            <span>Auto Play (ÊºîÁ§∫Ê®°Âºè)</span>
            <input type="checkbox" id="auto-mode-check">
        </div>

        <div class="setting-group-title">AUDIO & SOUND</div>
        <div class="setting-row">
            <span>Audio Offset (Âª∂Ëøü ms)</span>
            <div style="display:flex; align-items:center; gap:10px;">
                <input type="number" id="offset-input" value="0" style="width:60px;">
                <button onclick="startCalibration()" style="background:#222; border:1px solid #0ff; color:#0ff; cursor:pointer; border-radius:4px; padding:4px 8px; font-size:12px;">
                    ‚ô™ CALIBRATE
                </button>
            </div>
        </div>
        
        <div class="setting-row">
            <span>Hit Sound (ÊâìÂáªÈü≥Êïà)</span>
            <input type="checkbox" id="hitsound-check" checked>
        </div>

        <div class="setting-row">
            <span>Sound Pack (Èü≥ÊïàÁªÑ)</span>
            <select id="soundpack-select">
                <option value="loading">Loading...</option>
            </select>
        </div>

        <div class="setting-group-title" style="color:#666; border-color:#666;">DEBUG</div>
        <div class="setting-row" style="display: none;">
            <span style="color:#888;">Developer Mode</span>
            <input type="checkbox" id="dev-mode-check">
        </div>

        <div style="text-align:center; margin-top:30px;">
            <button class="main-btn" onclick="closeSettings()" style="padding:10px 40px; font-size:16px;">CLOSE</button>
        </div>
    </div>
</div>

<div id="update-modal" class="overlay" style="display:none; z-index: 100;">
    <div id="update-box">
        <div class="update-header">System Update // V1.3.0_alpha</div>
        <div class="update-content">
            <div class="update-list-item"><span class="update-tag">NEW</span><strong>Êñ∞Â¢ûÂäüËÉΩÔºöÊî∂‰ª∂ÁÆ±</strong><br><span style="color:#aaa;">Âú®Âè≥‰∏äËßíÊñ∞Â¢û‰∫Ü‚ÄúÊî∂‰ª∂ÁÆ±‚ÄùÔºåÂê¨ËØ¥N-07Áªô‰Ω†ÂÜô‰∫Ü‰∏ÄÂ∞Å‰ø°ÔºåËØ∑Âä°ÂøÖÁúã‰∏Ä‰∏ãÔºõ</span></div>
            <div class="update-list-item"><span class="update-tag">NEW</span><strong>Êñ∞Â¢ûbadÂà§ÂÆö</strong><br><span style="color:#aaa;">ËøáÂÖ≥Êõ¥ÂÆπÊòì‰∫ÜÔºÅ</span></div>
            <div class="update-list-item"><span class="update-tag">FIX</span><strong>‰øÆÂ§ç</strong><br><span style="color:#aaa;">‰øÆÂ§ç‰∫Ü‰∏Ä‰∫õÊí≠ÊîæÈü≥‰πêÂíåÈü≥ÊïàÁöÑbug</span></div>
        </div>
        <div style="text-align: center;"><button class="main-btn" onclick="closeUpdateModal()">CONFIRM</button></div>
    </div>
</div>

<div id="song-select-screen" class="overlay" style="display: none;">
    <!-- „ÄêNEW„ÄëÊî∂‰ª∂ÁÆ±ÊåâÈíÆ -->
    <button id="mailbox-btn" onclick="openMailbox()">
        <span style="font-size:20px;">üì©</span> ÈÇÆ‰ª∂
        <div id="mail-notification" class="badge-notification"></div>
    </button>

    <button id="settings-btn" onclick="openSettings()">
        <span style="font-size:20px;">‚öôÔ∏è</span> SETTINGS
    </button>
    <div id="category-bar"></div>
    <div class="content-wrapper">
        <div class="song-list-panel" id="song-list-container"></div>
        <div class="song-info-panel">
            <img id="preview-cover" class="cover-art" src="">
            <h1 id="preview-title" style="margin:5px;">-</h1>
            <p id="preview-artist" style="color:#0ff; margin:0;">-</p>
            <p id="preview-charter" style="color:#666; font-size:12px; margin-top:5px;">-</p>
            <button onclick="window.location.href='tutorial.html'" style="margin: 10px 0; background: transparent; border: 1px solid #0ff; color: #0ff; padding: 5px 20px; border-radius: 20px; cursor: pointer;">
                üìñ ËøõÂÖ•Êñ∞ÊâãÊïôÂ≠¶ (TUTORIAL)
            </button>
            <div class="diff-selector">
                <button class="diff-btn" data-diff="easy">EASY</button>
                <button class="diff-btn" data-diff="normal">NORMAL</button>
                <button class="diff-btn" data-diff="hard">HARD</button>
                <button class="diff-btn" data-diff="expert">EXPERT</button>
            </div>
            <div id="best-record-box">
                <div class="record-label">BEST SCORE</div>
                <div class="record-val" id="record-score-val">0000000</div>
                <div class="record-badge badge-none" id="record-badge-el">CLEAR</div>
            </div>
            <button id="btn-start" class="main-btn">START GAME</button>
        </div>
    </div>
</div>

<div id="result-screen" class="overlay" style="display:none;">
    <div id="result-card">
        <div id="new-record-badge" class="new-record-badge">NEW RECORD!</div>

        <h2 style="color:#aaa; letter-spacing:5px; margin:0;">RESULT</h2>
        <div id="res-grade" class="grade-big">S</div>
        <div id="res-score" style="font-size:40px; font-family:monospace;">0000000</div>
        <div id="failed-msg" class="failed-text">CHALLENGE FAILED</div>
        <div class="stat-grid">
            <div class="stat-row" style="color:#ff00ff"><span class="stat-label">CRITICAL</span><span class="stat-val" id="res-crit">0</span></div>
            <div class="stat-row" style="color:#ffffff"><span class="stat-label">PERFECT</span><span class="stat-val" id="res-perf">0</span></div>
            <div class="stat-row" style="color:#ffcc00"><span class="stat-label">GOOD</span><span class="stat-val" id="res-good">0</span></div>
            <!-- „ÄêNEW„ÄëÊñ∞Â¢û BAD ÁªüËÆ°Ë°å -->
            <div class="stat-row" style="color:#a300cc"><span class="stat-label">BAD</span><span class="stat-val" id="res-bad">0</span></div>
            <div class="stat-row" style="color:#ff0055"><span class="stat-label">MISS</span><span class="stat-val" id="res-miss">0</span></div>
            <div style="height:1px; background:#444; margin:5px 0;"></div>
            <div class="stat-row"><span class="stat-label">MAX COMBO</span><span class="stat-val" id="res-maxcombo">0</span></div>
        </div>
        <div id="stamp-area" style="height:100px; display:flex; align-items:center; justify-content:center;"></div>
        <button class="main-btn" onclick="backToMenu()" style="margin-top:10px;">BACK</button>
    </div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    let audioCtx, bgmSource, previewSource;
    let soundPackConfig = [];       
    let loadedBuffers = {};         
    let synthBuffer = null;         
    let currentSong = null;
    let currentChartOffset = 0; 
    let songList = [], filteredList = [];
    let currentTag = 'ALL', selectedDiff = 'normal';
    
    let previewRequestId = 0;

    const CLEAR_THRESHOLDS = {
        'easy': 600000,
        'normal': 600000,
        'hard': 700000,
        'expert': 800000
    };

    let userSettings = {
        speed: 2.0,
        inputMode: 'arrow', 
        offset: 0,
        devMode: false,
        autoMode: false,
        hitSound: true,       
        hitSoundPack: 'mp3'   
    };

    let isPlaying = false, isPaused = false, isCountingDown = false;
    let notes = [], events = [], particles = [];
    let startTime = 0;
    let audioBuffer = null;
    let stats = { score:0, rawScore:0, maxCombo:0, combo:0, miss:0, bad:0, good:0, perfect:0, critical:0, auto:0 };
    let totalScoreUnit = 0; 
    let animationFrameId;
    let shakeIntensity = 0; 
    let bgFlash = 0;
    
    let hitBuffers = []; 

    const LANE_COLORS = ['#ff0055', '#00ffaa', '#00ccff', '#ffcc00', '#d600ff'];
    const KEYS_MAP_ARROW = { 'ArrowUp': 0, 'ArrowRight': 1, 'ArrowDown': 2, 'ArrowLeft': 3, 'Space': 4 };
    const KEYS_MAP_WASD  = { 'KeyW': 0, 'KeyD': 1, 'KeyS': 2, 'KeyA': 3, 'Space': 4 };
    const HIT_RADIUS = 260;
    
    const JUDGE_CRITICAL = 0.04;
    const JUDGE_PERFECT = 0.08;
    const JUDGE_GOOD = 0.2;
    const JUDGE_BAD = 0.32;
    const JUDGE_TRAP = 0.35; 

    // --- „ÄêNEW„ÄëÊî∂‰ª∂ÁÆ±ÈÄªËæëÁ≥ªÁªü ---
    let mailData = [];
    // ÈªòËÆ§ÊºîÁ§∫ÈÇÆ‰ª∂ÔºåÈò≤Ê≠¢Ê≤°Êúâ mails.json Êñá‰ª∂Êó∂Êä•Èîô
    const DEFAULT_MAILS = [
        {
            id: "system_welcome",
            title: "Welcome to Neon Pulse",
            sender: "System",
            date: "2025-01-01",
            content: "Welcome, Runner!\n\nThis is your private inbox. Check here for updates, rewards, and messages from the developers.\n\nEnjoy the rhythm!"
        }
    ];

    async function initMailSystem() {
        try {
            // Â∞ùËØïËØªÂèñÂêåÁ∫ßÁõÆÂΩï‰∏ãÁöÑ mails.json Êñá‰ª∂
            const response = await fetch('mails.json');
            if (response.ok) {
                mailData = await response.json();
            } else {
                mailData = DEFAULT_MAILS;
            }
        } catch (e) {
            console.log("Could not load mails.json, using default.", e);
            mailData = DEFAULT_MAILS;
        }
        checkUnreadMails();
    }

    function checkUnreadMails() {
        const readList = JSON.parse(localStorage.getItem('neon_read_mails') || '[]');
        let unreadCount = 0;
        mailData.forEach(mail => {
            if (!readList.includes(mail.id)) unreadCount++;
        });
        
        const badge = document.getElementById('mail-notification');
        if (unreadCount > 0) {
            badge.style.display = 'block';
        } else {
            badge.style.display = 'none';
        }
    }

    window.openMailbox = function() {
        document.getElementById('mailbox-overlay').style.display = 'flex';
        renderMailList();
    };

    window.closeMailbox = function() {
        document.getElementById('mailbox-overlay').style.display = 'none';
        checkUnreadMails(); // ÂÖ≥Èó≠Êó∂Âà∑Êñ∞Á∫¢ÁÇπÁä∂ÊÄÅ
    };

    function renderMailList() {
        const container = document.getElementById('mail-list-container');
        container.innerHTML = '';
        
        const readList = JSON.parse(localStorage.getItem('neon_read_mails') || '[]');

        mailData.forEach((mail, index) => {
            const isRead = readList.includes(mail.id);
            const div = document.createElement('div');
            div.className = 'mail-item' + (isRead ? '' : ' unread');
            div.innerHTML = `
                <div class="mail-item-title">${mail.title}</div>
                <div class="mail-item-sender">${mail.sender}</div>
            `;
            div.onclick = () => selectMail(index, div);
            container.appendChild(div);
        });

        // Reset view
        document.getElementById('mail-empty-state').style.display = 'flex';
        document.getElementById('mail-detail-view').style.display = 'none';
    }

    function selectMail(index, el) {
        // UI Êõ¥Êñ∞
        document.querySelectorAll('.mail-item').forEach(i => i.classList.remove('active'));
        el.classList.add('active');
        el.classList.remove('unread'); // ËßÜËßâ‰∏äÂéªÊéâÊú™ËØªÊ†áËÆ∞

        const mail = mailData[index];
        
        // ÊòæÁ§∫ÂÜÖÂÆπ
        document.getElementById('mail-empty-state').style.display = 'none';
        const detailView = document.getElementById('mail-detail-view');
        detailView.style.display = 'flex';
        
        document.getElementById('mail-view-title').innerText = mail.title;
        document.getElementById('mail-view-sender').innerText = "From: " + mail.sender;
        document.getElementById('mail-view-date').innerText = mail.date || "";
        document.getElementById('mail-view-content').innerHTML = mail.content;

        // Ê†áËÆ∞‰∏∫Â∑≤ËØªÂπ∂‰øùÂ≠ò
        const readList = JSON.parse(localStorage.getItem('neon_read_mails') || '[]');
        if (!readList.includes(mail.id)) {
            readList.push(mail.id);
            localStorage.setItem('neon_read_mails', JSON.stringify(readList));
        }
    }

    // --- ÊàêÁª©Â≠òÂÇ®ÈÄªËæë ---
    const CLEAR_TYPE = {
        NONE: 0,
        FAILED: 1, 
        CLEAR: 2,  
        FC: 3,     
        AP: 4,     
        AC: 5      
    };

    function getStorageKey() {
        return 'neon_pulse_records_v1';
    }

    function loadRecords() {
        const data = localStorage.getItem(getStorageKey());
        return data ? JSON.parse(data) : {};
    }

    function saveRecord(songId, diff, score, clearType) {
        if (userSettings.autoMode || userSettings.devMode) {
            console.log("Auto/Dev mode active. Score not saved.");
            return; 
        }

        const records = loadRecords();
        const key = `${songId}_${diff}`;
        const existing = records[key] || { score: 0, clearType: 0 };

        let shouldSave = false;

        if (score > existing.score) {
            existing.score = score;
            shouldSave = true;
        }

        if (clearType > existing.clearType) {
            existing.clearType = clearType;
            shouldSave = true;
        }

        if (shouldSave) {
            records[key] = existing;
            localStorage.setItem(getStorageKey(), JSON.stringify(records));
        }
    }

    function updateRecordDisplay() {
        if (!currentSong) return;
        const records = loadRecords();
        const key = `${currentSong.id}_${selectedDiff}`;
        const rec = records[key];

        const scoreEl = document.getElementById('record-score-val');
        const badgeEl = document.getElementById('record-badge-el');

        if (rec) {
            scoreEl.innerText = rec.score.toString().padStart(7, '0');
            
            badgeEl.className = 'record-badge';
            badgeEl.style.display = 'block';

            switch (rec.clearType) {
                case CLEAR_TYPE.AC:
                    badgeEl.innerText = "ALL CRITICAL";
                    badgeEl.classList.add('badge-ac');
                    break;
                case CLEAR_TYPE.AP:
                    badgeEl.innerText = "ALL PERFECT";
                    badgeEl.classList.add('badge-ap');
                    break;
                case CLEAR_TYPE.FC:
                    badgeEl.innerText = "FULL COMBO";
                    badgeEl.classList.add('badge-fc');
                    break;
                case CLEAR_TYPE.CLEAR:
                    badgeEl.innerText = "CLEAR";
                    badgeEl.classList.add('badge-clear');
                    break;
                default:
                    badgeEl.style.display = 'none';
            }
        } else {
            scoreEl.innerText = "0000000";
            badgeEl.style.display = 'none';
        }
    }

    // --- (ÂàùÂßãÂåñÂèäÂÖ∂‰ªñÈÄªËæë) ---
    function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
    window.addEventListener('resize', resize); resize();

    function enterGame() {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        } else if (audioCtx.state === 'suspended') {
            audioCtx.resume();
        }
        loadHitSounds();
        initSynthSound();

        const splash = document.getElementById('splash-screen');
        splash.style.opacity = '0';
        splash.style.transform = 'scale(1.1)';
        
        setTimeout(() => {
            splash.style.display = 'none';
            document.getElementById('song-select-screen').style.display = 'flex';
            init(); 
        }, 500);
    }

    async function initSoundSystem() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        try {
            const res = await fetch('soundpacks.json');
            soundPackConfig = await res.json();
        } catch (e) {
            soundPackConfig = [{id: 'synth', name: 'Synth (Fallback)', type: 'synth'}];
        }
        const select = document.getElementById('soundpack-select');
        select.innerHTML = ''; 
        soundPackConfig.forEach(pack => {
            const opt = document.createElement('option');
            opt.value = pack.id;
            opt.innerText = pack.name;
            select.appendChild(opt);
        });
        if (userSettings.hitSoundPack) {
            const exists = soundPackConfig.find(p => p.id === userSettings.hitSoundPack);
            select.value = exists ? userSettings.hitSoundPack : soundPackConfig[0].id;
        } else {
            select.value = soundPackConfig[0].id;
        }
        select.addEventListener('change', async (e) => {
            const packId = e.target.value;
            userSettings.hitSoundPack = packId;
            saveSettings();
            await loadSoundPack(packId); 
        });
        initSynthSound(); 
        await loadSoundPack(select.value); 
    }

    async function loadSoundPack(packId) {
        if (!audioCtx) return;
        
        // ÁºìÂ≠òÊ£ÄÊü•ÔºöÂ¶ÇÊûúÂ∑≤ÁªèÂä†ËΩΩËøáÔºåÁõ¥Êé•ËøîÂõû
        if (loadedBuffers[packId] && loadedBuffers[packId].length > 0) {
            return; 
        }

        const pack = soundPackConfig.find(p => p.id === packId);
        if (!pack || pack.type === 'synth') return;
        
        const promises = pack.files.map(async (url) => {
            try {
                const res = await fetch(url);
                const buf = await res.arrayBuffer();
                return await audioCtx.decodeAudioData(buf);
            } catch (e) { 
                console.warn("Failed to load hit sound:", url);
                return null; 
            }
        });

        const buffers = await Promise.all(promises);
        // ËøáÊª§ÊéâÂä†ËΩΩÂ§±Ë¥•ÁöÑ null
        loadedBuffers[packId] = buffers.filter(b => b !== null);
    }

    function initSynthSound() {
        if (synthBuffer || !audioCtx) return;
        const duration = 0.12; 
        const sampleRate = audioCtx.sampleRate;
        const length = sampleRate * duration; 
        const buffer = audioCtx.createBuffer(1, length, sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < length; i++) {
            const t = i / length;
            const time = i / sampleRate;
            const freq = 523 + 50 * Math.exp(-50 * time);
            const wave = Math.sin(2 * Math.PI * freq * time) + Math.asin(Math.sin(2 * Math.PI * freq * time)) * 0.5;
            data[i] = wave * Math.pow(1 - t, 2.5) * 0.5;
        }
        synthBuffer = buffer;
    }

    async function init() {
        loadSettings();
        await initSoundSystem();
        initMailSystem(); // „ÄêNEW„ÄëÂàùÂßãÂåñÈÇÆ‰ª∂Á≥ªÁªü

        try {
            const res = await fetch('songs.json');
            songList = await res.json();
        } catch(e) {
            songList = [{ id:'demo', title:'Demo Song', artist:'System', charter:'AI', tags:['Demo'], cover:'', charts:{'normal':null}, audio:null }];
        }
        
        initCategoryBar();
        filterSongs('ALL'); 

        document.querySelectorAll('.diff-btn').forEach(btn => {
            btn.onclick = () => {
                if(btn.classList.contains('disabled')) return;
                selectedDiff = btn.dataset.diff;
                updateDiffUI();
                updateRecordDisplay(); 
            };
        });
        
        const speedInput = document.getElementById('speed-input');
        speedInput.value = userSettings.speed;
        document.getElementById('speed-val').innerText = parseFloat(userSettings.speed).toFixed(1);
        speedInput.addEventListener('input', e => {
            userSettings.speed = parseFloat(e.target.value);
            document.getElementById('speed-val').innerText = userSettings.speed.toFixed(1);
            saveSettings();
        });

        const modeSelect = document.getElementById('input-mode-select');
        modeSelect.value = userSettings.inputMode;
        modeSelect.addEventListener('change', e => { userSettings.inputMode = e.target.value; saveSettings(); });

        const offsetInput = document.getElementById('offset-input');
        offsetInput.value = userSettings.offset;
        offsetInput.addEventListener('change', e => { userSettings.offset = parseInt(e.target.value) || 0; saveSettings(); });

        const devCheck = document.getElementById('dev-mode-check');
        devCheck.checked = userSettings.devMode || false;
        devCheck.addEventListener('change', e => { userSettings.devMode = e.target.checked; saveSettings(); });

        const autoCheck = document.getElementById('auto-mode-check');
        autoCheck.checked = userSettings.autoMode || false;
        autoCheck.addEventListener('change', e => { userSettings.autoMode = e.target.checked; saveSettings(); });

        const soundCheck = document.getElementById('hitsound-check');
        soundCheck.checked = userSettings.hitSound !== false; 
        soundCheck.addEventListener('change', e => { userSettings.hitSound = e.target.checked; saveSettings(); });

        document.getElementById('btn-start').onclick = startGame;
        checkUpdatePopup();
    }

    function saveSettings() {
        localStorage.setItem('neon_settings_v4', JSON.stringify(userSettings));
    }

    function loadSettings() {
        const saved = localStorage.getItem('neon_settings_v4'); 
        if(saved) {
            try { userSettings = { ...userSettings, ...JSON.parse(saved) }; } catch(e) {}
        }
    }

    window.openSettings = function() { document.getElementById('settings-overlay').style.display = 'flex'; };
    window.closeSettings = function() {
        document.getElementById('settings-overlay').style.display = 'none';
        if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
    };

    async function loadHitSounds() {
        if (!audioCtx) return;
        hitBuffers = []; 
    }

    function playHitSound(lane) {
        if (!userSettings.hitSound || !audioCtx) return;
        if (audioCtx.state === 'suspended') audioCtx.resume();

        const currentPackId = userSettings.hitSoundPack;
        const packConfig = soundPackConfig.find(p => p.id === currentPackId);
        
        if (packConfig && packConfig.type === 'synth') {
            if (!synthBuffer) return;
            const source = audioCtx.createBufferSource();
            source.buffer = synthBuffer;
            source.detune.value = [400, 700, 200, 0, 1200][lane] || 0; 
            const gainNode = audioCtx.createGain();
            gainNode.gain.value = lane === 4 ? 0.8 : 0.6;
            source.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            source.start(0);
            return;
        }

        const buffers = loadedBuffers[currentPackId];
        if (buffers && buffers[lane]) {
            const source = audioCtx.createBufferSource();
            source.buffer = buffers[lane];
            const gainNode = audioCtx.createGain();
            gainNode.gain.value = (lane === 4) ? 1.0 : 0.8; 
            source.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            source.start(0);
        }
    }

    function initCategoryBar() {
        const bar = document.getElementById('category-bar');
        const tags = new Set(['ALL']);
        songList.forEach(s => (s.tags || []).forEach(t => tags.add(t)));
        bar.innerHTML = '';
        tags.forEach(tag => {
            const btn = document.createElement('button');
            btn.className = 'tag-btn' + (tag==='ALL'?' active':'');
            btn.innerText = tag;
            btn.onclick = () => {
                document.querySelectorAll('.tag-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                filterSongs(tag);
            };
            bar.appendChild(btn);
        });
    }

    function filterSongs(tag) {
        currentTag = tag;
        filteredList = tag === 'ALL' ? songList : songList.filter(s => (s.tags || []).includes(tag));
        renderSongList();
    }

    function renderSongList() {
        const c = document.getElementById('song-list-container');
        c.innerHTML = '';
        if(!filteredList.length) { c.innerHTML='<div style="padding:20px;color:#666">No songs</div>'; return; }
        filteredList.forEach((s, i) => {
            const d = document.createElement('div');
            d.className = 'song-item';
            d.innerHTML = `<div style="font-weight:bold;">${s.title}</div><div style="font-size:12px; color:#aaa;">${s.artist}</div>`;
            d.onclick = () => selectSong(i);
            c.appendChild(d);
        });
        selectSong(0);
    }

    function selectSong(idx) {
        document.querySelectorAll('.song-item').forEach(e=>e.classList.remove('selected'));
        if(filteredList[idx]) document.querySelectorAll('.song-item')[idx].classList.add('selected');
        currentSong = filteredList[idx];
        if(!currentSong) return;

        previewRequestId++;

        document.getElementById('preview-title').innerText = currentSong.title;
        document.getElementById('preview-artist').innerText = currentSong.artist;
        document.getElementById('preview-charter').innerText = "Charter: " + (currentSong.charter||"?");
        document.getElementById('preview-cover').src = currentSong.cover||'';
        document.getElementById('bg-layer').style.backgroundImage = `url('${currentSong.cover}')`;

        const charts = currentSong.charts||{};
        document.querySelectorAll('.diff-btn').forEach(btn => {
            const d = btn.dataset.diff;
            const hasChart = charts[d] || (currentSong.id === 'demo' && d==='normal');
            if (!hasChart) btn.classList.add('disabled');
            else btn.classList.remove('disabled');
        });

        if (!charts[selectedDiff] && currentSong.id!=='demo') {
             const available = Object.keys(charts).find(k => charts[k]);
             if (available) selectedDiff = available;
        }

        updateDiffUI();
        updateRecordDisplay(); 
        playPreview(currentSong, previewRequestId);
    }

    function updateDiffUI() {
        document.querySelectorAll('.diff-btn').forEach(btn => {
            btn.classList.remove('active');
            if(btn.dataset.diff === selectedDiff) {
                btn.classList.add('active');
            }
        });
    }

    async function playPreview(song, reqId) {
        stopPreview();
        if(!song.audio) return;
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') try{await audioCtx.resume();}catch(e){}
        try {
            const buf = await fetch(song.audio).then(r=>r.arrayBuffer()).then(d=>audioCtx.decodeAudioData(d));
            if (reqId !== previewRequestId) return;
            previewSource = audioCtx.createBufferSource();
            previewSource.buffer = buf;
            previewSource.connect(audioCtx.destination);
            const start = song.preview_start || 10;
            previewSource.loop = true; previewSource.loopStart = start; previewSource.loopEnd = start+30;
            previewSource.start(0, start);
        } catch(e){}
    }
    function stopPreview() { if(previewSource) { try{previewSource.stop();}catch(e){}; previewSource=null; } }

    async function startGame() {
        previewRequestId++; 
        stopPreview();      

        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') await audioCtx.resume();

        const loadingOverlay = document.getElementById('loading-overlay');
        loadingOverlay.style.display = 'flex';
        document.getElementById('loading-text').innerText = "Loading Assets & Decoding...";
        document.getElementById('song-select-screen').style.display = 'none';
        
        try {
            // 1. ÂáÜÂ§áÂä†ËΩΩ‰ªªÂä°ÂàóË°®
            const tasks = [];

            // A. ‰ªªÂä°ÔºöÂä†ËΩΩË∞±Èù¢ÂíåÈü≥‰πê
            if (currentSong.id === 'demo') {
                // Demo Ê≠åÊõ≤ÁöÑÁâπÊÆäÂ§ÑÁêÜÔºàÁîüÊàêÊ®°ÊãüÊï∞ÊçÆÔºâ
                tasks.push(new Promise(async (resolve) => {
                     await new Promise(r => setTimeout(r, 1000)); // Ê®°ÊãüÂä†ËΩΩÂª∂Ëøü
                     const sr = audioCtx.sampleRate;
                     audioBuffer = audioCtx.createBuffer(1, sr * 30, sr);
                     // ÁÆÄÂçïÁöÑÁîüÊàêÈùôÈü≥ÊàñÁôΩÂô™‰Ωú‰∏∫DemoÈü≥È¢ë
                     const data = audioBuffer.getChannelData(0);
                     for(let i=0; i<data.length; i++) data[i] = (Math.random() * 2 - 1) * 0.1;
                     
                     notes = []; events = [{time:5, type:'shake'}, {time:10, type:'shake'}];
                     for(let i=0; i<30; i++) notes.push({time:2+i*0.8, lane:i%5, duration:i%4===0?1:0});
                     resolve();
                }));
            } else {
                // Ê≠£Â∏∏Ê≠åÊõ≤ÔºöÂä†ÂÖ• Fetch ‰ªªÂä°
                const chartUrl = currentSong.charts[selectedDiff];
                
                // ‰ªªÂä°ÔºöËé∑ÂèñÂπ∂Ëß£Á†ÅÊ≠åÊõ≤Èü≥È¢ë
                const audioTask = fetch(currentSong.audio)
                    .then(r => r.arrayBuffer())
                    .then(buffer => audioCtx.decodeAudioData(buffer))
                    .then(decoded => { audioBuffer = decoded; });
                
                // ‰ªªÂä°ÔºöËé∑ÂèñË∞±Èù¢JSON
                const chartTask = fetch(chartUrl)
                    .then(r => r.json())
                    .then(data => {
                        notes = data.notes || [];
                        events = data.events || [];
                        currentChartOffset = data.offset || 0;
                    });

                tasks.push(audioTask);
                tasks.push(chartTask);
            }

            // B. ÂÖ≥ÈîÆ‰øÆÂ§çÔºöÂä†ÂÖ•Èü≥ÊïàÂä†ËΩΩ‰ªªÂä°
            // Á°Æ‰øùÂΩìÂâçÈÄâÊã©ÁöÑÈü≥ÊïàÂåÖÂ∑≤Âä†ËΩΩ„ÄÇÂ¶ÇÊûúÂ∑≤Âä†ËΩΩÔºåloadSoundPack ‰ºöÁõ¥Êé•ËøîÂõûÔºàÈúÄË¶ÅÂæÆË∞É loadSoundPack ÈÄªËæëÊàñ‰ø°‰ªªÂÖ∂ÁºìÂ≠òÊú∫Âà∂Ôºâ
            // ËøôÈáåÊàë‰ª¨Áõ¥Êé•Ë∞ÉÁî® loadSoundPackÔºåÂõ†‰∏∫ÂÆÉÂÜÖÈÉ®Â∫îËØ•Â§ÑÁêÜÁºìÂ≠òÊ£ÄÊü•
            const currentPackId = userSettings.hitSoundPack;
            if (currentPackId && currentPackId !== 'synth') {
                // Â¶ÇÊûúÁºìÂ≠òÈáåÊ≤°ÊúâËøô‰∏™ÂåÖÁöÑÊï∞ÊçÆÔºåÊàñËÄÖËôΩÁÑ∂ÊúâKey‰ΩÜÊï∞ÊçÆ‰∏∫Á©∫ÔºåÂàôÂº∫Âà∂Á≠âÂæÖÂä†ËΩΩ
                if (!loadedBuffers[currentPackId] || loadedBuffers[currentPackId].length === 0) {
                     document.getElementById('loading-text').innerText = "Downloading Sound Effects...";
                     tasks.push(loadSoundPack(currentPackId));
                }
            }

            // 2. Á≠âÂæÖÊâÄÊúâËµÑÊ∫êÔºàÈü≥‰πê„ÄÅË∞±Èù¢„ÄÅÈü≥ÊïàÔºâÂÖ®ÈÉ®Â∞±Áª™
            await Promise.all(tasks);

        } catch(e) { 
            console.error(e);
            alert("Error loading game data. Please check your connection."); 
            loadingOverlay.style.display = 'none'; 
            backToMenu(); 
            return; 
        }

        // ÊâÄÊúâÊï∞ÊçÆÂáÜÂ§áÂÆåÊØïÔºåËøõÂÖ•Ê∏∏Êàè
        loadingOverlay.style.display = 'none';
        document.getElementById('hud').style.display = 'block';
        document.getElementById('bg-layer').style.opacity = 0.5;

        stopPreview(); 

        const clearScore = CLEAR_THRESHOLDS[selectedDiff] || 600000;
        const markerPct = (clearScore / 1000000) * 100;
        document.getElementById('score-bar-marker').style.bottom = markerPct + "%";
        document.getElementById('score-bar-marker').classList.remove('marker-passed');
        const barFill = document.getElementById('score-bar-fill');
        barFill.style.height = "0%";
        barFill.className = ''; 

        const autoIndicator = document.getElementById('auto-indicator');
        autoIndicator.style.display = userSettings.autoMode ? 'block' : 'none';

        if(userSettings.devMode) document.getElementById('hud-detail').innerHTML += " DEV";

        checkSimultaneousNotes();
        notes.forEach(n => { n.hit=false; n.processed=false; n.headHit=false; n.tailHit=false; n.holding=false; });
        events.forEach(e => e.triggered=false);
        
        let maxCombo = 0;
        notes.forEach(n => maxCombo += (n.duration>0 ? 2 : 1));
        totalScoreUnit = 1000000 / (maxCombo||1);

        stats = { score:0, rawScore:0, maxCombo:0, combo:0, miss:0, bad:0, good:0, perfect:0, critical:0, auto:0 };
        particles = [];
        shakeIntensity = 0; bgFlash = 0;

        document.getElementById('hud-title').innerText = currentSong.title;
        document.getElementById('hud-detail').innerText = `${currentSong.artist} - ${selectedDiff.toUpperCase()}`;
        document.getElementById('score-display').innerText = "0000000";
        document.getElementById('combo-display').style.opacity = 0;

        bgmSource = audioCtx.createBufferSource();
        bgmSource.buffer = audioBuffer;
        bgmSource.connect(audioCtx.destination);
        bgmSource.start(0);
        startTime = audioCtx.currentTime;
        isPlaying = true; isPaused = false; isCountingDown = false;

        cancelAnimationFrame(animationFrameId);
        gameLoop();
    }

    function checkSimultaneousNotes() {
        notes.sort((a,b) => a.time - b.time);
        for(let i=0; i<notes.length; i++) notes[i].isSync = false;
        for(let i=0; i<notes.length; i++) {
            let n1 = notes[i];
            for(let j=i+1; j<notes.length; j++) {
                let n2 = notes[j];
                if(Math.abs(n2.time - n1.time) < 0.05) {
                    n1.isSync = true; n2.isSync = true;
                } else break;
            }
        }
    }

    function gameLoop() {
        if (!isPlaying || isPaused || isCountingDown) return;
        animationFrameId = requestAnimationFrame(gameLoop);
        const rawTime = audioCtx.currentTime - startTime;
        const now = rawTime - (userSettings.offset / 1000);
        if (rawTime > audioBuffer.duration + 1.5) { finishGame(); return; }
        
        events.forEach(e => { if(!e.triggered && now >= e.time) { e.triggered = true; if(e.type === 'shake') { shakeIntensity = 30; bgFlash = 1.0; } } });
        shakeIntensity *= 0.9; bgFlash *= 0.9; if(bgFlash < 0.01) bgFlash = 0;
        document.getElementById('bg-layer').style.filter = `blur(8px) brightness(${0.5 + bgFlash})`;
        document.getElementById('progress-bar').style.width = ((rawTime/audioBuffer.duration)*100) + "%";

        notes.forEach(n => {
            if (!n.processed && !n.headHit && now >= n.time && (userSettings.devMode || userSettings.autoMode)) {
                n.headHit = true; createExplosion(n.lane); 
                const hitType = userSettings.autoMode ? 'auto' : 'critical';
                if (n.duration === 0) { n.processed = true; handleHit(hitType, n.lane); }
                else { n.holding = true; handleHit(hitType, n.lane); }
            }
            if (n.holding && now >= n.time + n.duration && (userSettings.devMode || userSettings.autoMode)) {
                n.holding = false; n.processed = true; createExplosion(n.lane); handleHit(userSettings.autoMode ? 'auto' : 'critical', n.lane);
            }
        });
        // „ÄêMODIFIED„Äë ËøôÈáåÁöÑËá™Âä® Miss Âà§ÂÆöÊó∂Èó¥Ë¶ÅÊîπÊàê JUDGE_BAD
        // Âè™ÊúâÂΩìÊó∂Èó¥Ë∂ÖËøá‰∫Ü BAD Á™óÂè£ÔºåÊâçÁÆóÂΩªÂ∫ïÈîôËøá
        notes.forEach(n => {
            if(n.processed) return;
            if(!userSettings.devMode && !userSettings.autoMode) {
                // Â¶ÇÊûúÂΩìÂâçÊó∂Èó¥Ë∂ÖËøá‰∫Ü BAD Á™óÂè£ÔºåÊâçÂà§ÂÆö‰∏∫ MISS
                if(!n.headHit && now > n.time + JUDGE_BAD) { n.processed = true; handleHit('miss', n.lane); }
                // ÈïøÊåâÂ∞æÈÉ®ÂêåÁêÜ
                if(n.holding && now > n.time + n.duration + JUDGE_BAD) { n.holding = false; n.processed = true; handleHit('miss', n.lane); }
            }
        });

        ctx.save(); ctx.clearRect(0,0,canvas.width,canvas.height);

        ctx.save(); ctx.clearRect(0,0,canvas.width,canvas.height);
        if (shakeIntensity > 0) {
            const dx = (Math.random() - 0.5) * shakeIntensity;
            const dy = (Math.random() - 0.5) * shakeIntensity;
            ctx.translate(canvas.width/2 + dx, canvas.height/2 + dy);
            ctx.translate(-canvas.width/2, -canvas.height/2);
        }
        const cx = canvas.width/2, cy = canvas.height/2;
        const travel = 3.0 / userSettings.speed;
        drawGameContent(cx, cy, now, travel, false);
        ctx.restore(); 
        document.getElementById('score-display').innerText = stats.score.toString().padStart(7,'0');
    }
    
    function drawGameContent(cx, cy, now, travel, isGhost) {
        ctx.beginPath(); ctx.arc(cx,cy,HIT_RADIUS,0,6.28); 
        ctx.lineWidth=3; ctx.strokeStyle='#fff'; ctx.stroke();
        drawLanes(cx, cy, isGhost);
        notes.forEach(n => {
            if(n.processed) return;
            const diffHead = n.time - now;
            if(n.duration>0) {
                const diffTail = (n.time+n.duration) - now;
                let rHead = (1-diffHead/travel)*HIT_RADIUS;
                if(n.holding) rHead = HIT_RADIUS; 
                let rTail = (1-diffTail/travel)*HIT_RADIUS;
                if(rHead>0 && rTail<HIT_RADIUS) {
                    let drawStart = Math.max(0, rTail); let drawEnd = Math.min(HIT_RADIUS, rHead);
                    if(drawEnd > drawStart) drawNoteBody(cx, cy, n.lane, drawEnd, drawStart, isGhost);
                    if(rTail > 0 && rTail <= HIT_RADIUS) drawNoteHead(cx, cy, n.lane, rTail, n.isSync, false, isGhost); 
                }
            }
            if(diffHead>travel || n.holding) return;
            const r = (1-diffHead/travel)*HIT_RADIUS;
            if(r>0) drawNoteHead(cx, cy, n.lane, r, n.isSync, false, isGhost);
        });
        if(!isGhost) updateParticles();
    }
    function drawLanes(cx, cy, isGhost) {
        [0,1,2,3].forEach(i => {
            const ang = [-1.57,0,1.57,3.14][i];
            const x = cx+Math.cos(ang)*HIT_RADIUS, y = cy+Math.sin(ang)*HIT_RADIUS;
            ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(x,y); 
            ctx.lineWidth=2; ctx.strokeStyle='rgba(255,255,255,0.1)'; ctx.stroke();
            ctx.beginPath(); ctx.arc(x,y,18,0,6.28); ctx.fillStyle='rgba(0,0,0,0.5)'; ctx.fill();
            ctx.strokeStyle=LANE_COLORS[i]; ctx.lineWidth=3; ctx.stroke();
        });
        ctx.beginPath(); ctx.arc(cx,cy,35,0,6.28); ctx.strokeStyle='rgba(214,0,255,0.4)'; ctx.stroke();
    }
    function drawNoteBody(cx, cy, lane, rHead, rTail, isGhost) {
        const ang = [-1.57,0,1.57,3.14][lane]||0;
        if(lane===4) {
            ctx.beginPath(); ctx.arc(cx, cy, rHead, 0, 6.28); ctx.arc(cx, cy, rTail, 0, 6.28, true); ctx.fillStyle='rgba(214,0,255,0.3)'; ctx.fill();
        } else {
            const x1=cx+Math.cos(ang)*rHead, y1=cy+Math.sin(ang)*rHead;
            const x2=cx+Math.cos(ang)*rTail, y2=cy+Math.sin(ang)*rTail;
            ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.strokeStyle=LANE_COLORS[lane]; ctx.lineWidth=10; ctx.stroke();
        }
    }
    function drawNoteHead(cx, cy, lane, r, isSync, isHolding, isGhost) {
        if (isSync) {
            ctx.beginPath();
            if (lane === 4) ctx.arc(cx, cy, r + 4, 0, 6.28);
            else { const ang = [-1.57,0,1.57,3.14][lane]; const x = cx + Math.cos(ang) * r, y = cy + Math.sin(ang) * r; ctx.arc(x, y, 19, 0, 6.28); }
            ctx.strokeStyle = '#FFD700'; ctx.lineWidth = 3; ctx.stroke();
        }
        if(lane===4) {
            ctx.beginPath(); ctx.arc(cx,cy,r,0,6.28); ctx.strokeStyle=LANE_COLORS[4]; ctx.lineWidth=6; ctx.stroke();
            if(isHolding) { ctx.fillStyle='rgba(255,255,255,0.5)'; ctx.fill(); }
        } else {
            const ang = [-1.57,0,1.57,3.14][lane]; const x=cx+Math.cos(ang)*r, y=cy+Math.sin(ang)*r;
            ctx.beginPath(); ctx.arc(x,y,15,0,6.28); ctx.fillStyle=LANE_COLORS[lane]; ctx.fill();
            if(isHolding) { ctx.fillStyle='#fff'; ctx.fill(); }
        }
    }
    window.addEventListener('keydown', e => {
        if(e.code === 'Escape') {
            if(document.getElementById('mailbox-overlay').style.display === 'flex') { closeMailbox(); return; }
            if(document.getElementById('settings-overlay').style.display === 'flex') { closeSettings(); return; }
            if(isPlaying) { if(isPaused) startResumeCountdown(); else pauseGame(); } return;
        }
        if (userSettings.devMode || userSettings.autoMode || !isPlaying || isPaused || isCountingDown || e.repeat) return;
        const map = userSettings.inputMode === 'wasd' ? KEYS_MAP_WASD : KEYS_MAP_ARROW;
        const lane = map[e.code];
        if (lane !== undefined) {
            if(e.code==='Space') e.preventDefault();
            const rawTime = audioCtx.currentTime - startTime;
            const now = rawTime - (userSettings.offset / 1000);
            const note = notes.find(n => !n.processed && !n.headHit && n.lane===lane && Math.abs(n.time-now) < JUDGE_TRAP);
            if(note) {
                const diff = note.time - now;
                const absDiff = Math.abs(diff);
                // „ÄêMODIFIED„Äë Âà§ÂÆöÈÄªËæëÂ¢ûÂä† BAD
                if (absDiff < JUDGE_GOOD) {
                    note.headHit = true;
                    let type = 'good'; 
                    if(absDiff < JUDGE_CRITICAL) type = 'critical'; 
                    else if(absDiff < JUDGE_PERFECT) type = 'perfect';
                    
                    if(note.duration>0) { note.holding = true; handleHit(type, lane); } 
                    else { note.processed = true; handleHit(type, lane); }
                    createExplosion(lane);
                } else if (absDiff < JUDGE_BAD) {
                    // „ÄêNEW„Äë BAD Âà§ÂÆöÈÄªËæë
                    // ‰ªã‰∫é GOOD Âíå MISS ‰πãÈó¥
                    note.headHit = true;
                    if(note.duration>0) { note.holding = true; handleHit('bad', lane); }
                    else { note.processed = true; handleHit('bad', lane); }
                    // BAD ÊòØÂê¶ÊúâÊâìÂáªÁâπÊïàÔºüÂèØ‰ª•ÊúâÔºå‰πüÂèØ‰ª•Ê≤°ÊúâÔºåËøôÈáåÁªô‰∏™Â∞èÂèçÈ¶à
                    createExplosion(lane); 
                } else { 
                    // Ë∂ÖËøá‰∫Ü BAD ‰ΩÜÂú® TRAP ËåÉÂõ¥ÂÜÖ (Â§™Êó©Êåâ‰∫ÜÊàñËÄÖÂ§™ÊôöÊåâ‰∫Ü)
                    // ÂéüÊúâÈÄªËæëÊòØÁõ¥Êé• MISS
                    note.processed = true; handleHit('miss', lane); 
                }
            }
        }
    });
    window.addEventListener('keyup', e => {
        if (userSettings.devMode || userSettings.autoMode || !isPlaying || isPaused || isCountingDown) return;
        const map = userSettings.inputMode === 'wasd' ? KEYS_MAP_WASD : KEYS_MAP_ARROW;
        const lane = map[e.code];
        if(lane!==undefined) {
            const rawTime = audioCtx.currentTime - startTime;
            const now = rawTime - (userSettings.offset / 1000);
            const note = notes.find(n => n.holding && n.lane===lane);
            if(note) {
                note.holding = false; note.processed = true;
                const diff = (note.time + note.duration) - now;
                const absDiff = Math.abs(diff);
                // „ÄêMODIFIED„Äë ÈïøÊåâÊùæÊâãÂà§ÂÆöÂ¢ûÂä† BAD
                if(absDiff < JUDGE_GOOD) {
                    if(absDiff < JUDGE_CRITICAL) handleHit('critical', lane); 
                    else if(absDiff < JUDGE_PERFECT) handleHit('perfect', lane); 
                    else handleHit('good', lane);
                } else if (absDiff < JUDGE_BAD) {
                    // „ÄêNEW„Äë ÈïøÊåâÊùæÊâã BAD
                    handleHit('bad', lane);
                } else { 
                    handleHit('miss', lane); 
                }
            }
        }
    });

    // „ÄêMODIFIED„Äë Ê†∏ÂøÉÂ§ÑÁêÜÂáΩÊï∞ÔºöÂ¢ûÂä† bad Á±ªÂûã
    function handleHit(type, lane) {
        if (type !== 'miss') playHitSound(lane);
        
        let text="", color="#fff", isRainbow=false;
        
        if(type==='miss') { 
            stats.combo=0; stats.miss++; text="MISS"; color="#f05"; 
        } 
        else if (type === 'bad') {
            // „ÄêNEW„Äë BAD ÁöÑÂ§ÑÁêÜÈÄªËæë
            stats.combo = 0; // BAD Êñ≠ËøûÂáª
            stats.bad++;     // ËÆ°Êï∞Â¢ûÂä†
            let val = totalScoreUnit * 0.2; // ÂàÜÊï∞Áªô‰∫à 20%
            text = "BAD";
            color = "#a300cc"; // Á¥´Ëâ≤
            stats.rawScore += val; 
            stats.score = Math.min(1000000, Math.round(stats.rawScore));
        }
        else {
            stats.combo++; 
            if(stats.combo > stats.maxCombo) stats.maxCombo = stats.combo;
            
            let val=0;
            if (type === 'auto') { stats.auto++; val = totalScoreUnit; text = "AUTO"; color = "#00ccff"; }
            else if(type==='critical') { stats.critical++; val=totalScoreUnit; text="PERFECT"; isRainbow=true; }
            else if(type==='perfect') { stats.perfect++; val=totalScoreUnit; text="PERFECT"; }
            else { 
                // Good
                stats.good++; val=totalScoreUnit*0.5; text="GOOD"; color="#fc0"; 
            }
            stats.rawScore += val; stats.score = Math.min(1000000, Math.round(stats.rawScore));
        }
        const cEl = document.getElementById('combo-display');
        cEl.innerText = stats.combo>0 ? "COMBO "+stats.combo : "";
        cEl.style.opacity = stats.combo>0 ? 1 : 0;
        const scorePct = (stats.score / 1000000) * 100;
        const barFill = document.getElementById('score-bar-fill');
        barFill.style.height = scorePct + "%";
        const clearScore = CLEAR_THRESHOLDS[selectedDiff];
        if (stats.score >= clearScore && !barFill.classList.contains('score-bar-cleared')) {
            barFill.classList.add('score-bar-cleared'); document.getElementById('score-bar-marker').classList.add('marker-passed');
        }
        if(lane!==undefined) {
            const pos = getPosFromLane(lane);
            if(type!=='miss') createExplosion(lane); 
            createFloatText(pos.x, pos.y, text, color, isRainbow);
        }
    }
    function createExplosion(lane) {
        const pos = getPosFromLane(lane);
        for(let i=0; i<15; i++) particles.push({ x:pos.x, y:pos.y, vx:(Math.random()-0.5)*15, vy:(Math.random()-0.5)*15, life:1, color:LANE_COLORS[lane], type:'spark'});
    }
    function createFloatText(x, y, t, c, r) { particles.push({ x, y, text:t, color:c, isRainbow:r, life:1, type:'text' }); }
    function getPosFromLane(l) {
        if(l===4) return {x:canvas.width/2, y:canvas.height/2};
        const a = [-1.57,0,1.57,3.14][l];
        return { x:canvas.width/2+Math.cos(a)*HIT_RADIUS, y:canvas.height/2+Math.sin(a)*HIT_RADIUS };
    }
    function updateParticles() {
        for(let i=particles.length-1; i>=0; i--) {
            let p=particles[i];
            if(p.type==='spark') {
                p.x+=p.vx; p.y+=p.vy; p.life-=0.05;
                ctx.globalAlpha=p.life; ctx.fillStyle=p.color; ctx.fillRect(p.x,p.y,4,4);
            } else {
                p.y-=2; p.life-=0.02; ctx.globalAlpha=Math.max(0,p.life);
                ctx.font="900 24px Arial"; ctx.textAlign="center";
                if(p.isRainbow) {
                    const g=ctx.createLinearGradient(p.x-30,p.y,p.x+30,p.y); g.addColorStop(0,"red"); g.addColorStop(1,"violet"); ctx.fillStyle=g;
                } else ctx.fillStyle=p.color;
                ctx.fillText(p.text,p.x,p.y); ctx.strokeStyle="black"; ctx.lineWidth=2; ctx.strokeText(p.text,p.x,p.y);
            }
            if(p.life<=0) particles.splice(i,1);
        }
        ctx.globalAlpha=1;
    }

    function pauseGame() {
        if(isCountingDown) return; isPaused = true; audioCtx.suspend(); document.getElementById('pause-menu').style.display = 'flex';
    }
    function startResumeCountdown() {
        document.getElementById('pause-menu').style.display = 'none'; isCountingDown = true;
        const countEl = document.getElementById('countdown-overlay'); countEl.style.display = 'flex';
        let count = 5; countEl.innerText = count;
        const timer = setInterval(() => {
            count--; if(count > 0) countEl.innerText = count;
            else { clearInterval(timer); countEl.style.display = 'none'; isPaused = false; isCountingDown = false; audioCtx.resume(); gameLoop(); }
        }, 1000);
    }
    window.startResumeCountdown = startResumeCountdown;
    window.resumeGame = startResumeCountdown; 

    window.retryGame = function() {
        if(bgmSource) { try { bgmSource.stop(); } catch(e){} }
        
        isPlaying = false;
        isPaused = false;
        isCountingDown = false;
        
        document.getElementById('pause-menu').style.display = 'none';
        document.getElementById('countdown-overlay').style.display = 'none';
        
        startGame();
    };

    window.backToMenu = function() {
        // 1. ÂÅúÊ≠¢Êí≠Êîæ
        if(bgmSource) {
            try{ bgmSource.stop(); } catch(e){}
            bgmSource.disconnect(); // Êñ≠ÂºÄËøûÊé•
            bgmSource = null;
        }

        // 2. Ê∏ÖÁêÜÂΩìÂâçÊ≠åÊõ≤ÁöÑÂ§ßÂûãËµÑÊ∫ê (ÂÜÖÂ≠ò‰ºòÂåñ)
        audioBuffer = null; 
        notes = [];
        events = [];
        particles = [];

        // Ê≥®ÊÑèÔºöÊàë‰ª¨ÈÄöÂ∏∏ *‰∏ç* Âà†Èô§ loadedBuffers (ÊâìÂáªÈü≥Êïà)Ôºå
        // Âõ†‰∏∫‰∏ãÊ¨°ËøõÊ∏∏ÊàèËøòÈúÄË¶ÅÁî®ÔºåÈáçÊñ∞‰∏ãËΩΩ‰ºöÂèòÊÖ¢„ÄÇ
        // Â¶ÇÊûú‰Ω†ÂøÖÈ°ªÂº∫Âà∂Ê∏ÖÁêÜÊâÄÊúâÁºìÂ≠òÔºà‰æãÂ¶Ç‰∏∫‰∫ÜÂÜÖÂ≠òÊûÅÂ∫¶Á¥ßÂº†ÁöÑËÆæÂ§áÔºâÔºåÂèñÊ∂à‰∏ãÈù¢Ê≥®ÈáäÔºö
        // loadedBuffers = {}; 
        
        isPlaying = false;
        cancelAnimationFrame(animationFrameId);
        
        // 3. UI ÊÅ¢Â§ç
        document.getElementById('pause-menu').style.display='none';
        document.getElementById('hud').style.display='none';
        document.getElementById('result-screen').style.display='none';
        document.getElementById('countdown-overlay').style.display='none';
        document.getElementById('song-select-screen').style.display='flex';
        document.getElementById('loading-overlay').style.display='none'; 
        document.getElementById('bg-layer').style.opacity = 0.5;
        document.getElementById('bg-layer').style.filter = "blur(8px) brightness(0.5)";
        
        // 4. ÊÅ¢Â§çÈ¢ÑËßà
        previewRequestId++;
        updateRecordDisplay(); 
        if(currentSong) playPreview(currentSong, previewRequestId);
    };

    // „ÄêMODIFIED„Äë finishGame ÈúÄË¶ÅÊòæÁ§∫ BAD ÁªüËÆ°
    function finishGame() {
        isPlaying = false;
        cancelAnimationFrame(animationFrameId);
        document.getElementById('hud').style.display='none';
        document.getElementById('result-screen').style.display='flex';
        
        const scoreEl = document.getElementById('res-score');
        const newRecordBadge = document.getElementById('new-record-badge');
        
        newRecordBadge.style.display = 'none';

        if (userSettings.autoMode) {
            scoreEl.innerText = "AUTO"; scoreEl.style.color = "#00ccff";
        } else {
            scoreEl.innerText = stats.score; scoreEl.style.color = "#fff";
        }

        document.getElementById('res-crit').innerText = userSettings.autoMode ? stats.auto : stats.critical;
        document.getElementById('res-perf').innerText = stats.perfect;
        document.getElementById('res-good').innerText = stats.good;
        // „ÄêNEW„Äë ÊòæÁ§∫ Bad Êï∞Èáè
        document.getElementById('res-bad').innerText = stats.bad;
        document.getElementById('res-miss').innerText = stats.miss;
        document.getElementById('res-maxcombo').innerText = stats.maxCombo;

        const msg = document.getElementById('failed-msg');
        const threshold = CLEAR_THRESHOLDS[selectedDiff];
        let isCleared = stats.score >= threshold;

        if (!isCleared && !userSettings.autoMode) {
            msg.innerText = "CHALLENGE FAILED"; msg.style.display = 'block';
        } else {
            msg.style.display = 'none';
        }
        
        const area = document.getElementById('stamp-area');
        area.innerHTML = '';
        const d = document.createElement('div');

        let clearType = CLEAR_TYPE.NONE;
        if (isCleared) clearType = CLEAR_TYPE.CLEAR;

        if (userSettings.autoMode) {
            d.innerText = "AUTO MODE"; d.className = "stamp-auto"; area.appendChild(d);
        } else {
            // „ÄêMODIFIED„Äë ‰øÆÊîπ Full Combo ÁöÑÂà§ÂÆöÊù°‰ª∂
            // Âè™Êúâ Miss Âíå Bad ÈÉΩÊòØ 0 Êó∂ÔºåÊâçÁÆó FC
            if(stats.miss === 0 && stats.bad === 0) {
                if (stats.good === 0 && stats.perfect === 0) {
                    d.innerText = "ALL CRITICAL"; 
                    d.className = "stamp-critical";
                    clearType = CLEAR_TYPE.AC;
                } else {
                    d.className = "stamp-normal";
                    if (stats.good === 0) {
                        d.innerText = "ALL PERFECT"; 
                        d.style.color = "#0ff";
                        clearType = CLEAR_TYPE.AP;
                    } else {
                        d.innerText = "FULL COMBO"; 
                        d.style.color = "#fc0";
                        clearType = CLEAR_TYPE.FC;
                    }
                }
                area.appendChild(d);
            }

            const currentKey = `${currentSong.id}_${selectedDiff}`;
            const savedData = loadRecords()[currentKey];
            const oldScore = savedData ? savedData.score : 0;

            if (stats.score > oldScore) {
                newRecordBadge.style.display = 'block'; 
            }

            saveRecord(currentSong.id, selectedDiff, stats.score, clearType);
        }
        
        let grade='F', color='#888';
        if(stats.score>=950000) { grade='S'; color='#d600ff'; }
        else if(stats.score>=900000) { grade='A'; color='#0ff'; }
        else if(stats.score>=800000) { grade='B'; color='#0f0'; }
        else if(stats.score>=600000) { grade='C'; color='#ff0'; }
        
        const gEl = document.getElementById('res-grade');
        gEl.innerText = grade; gEl.style.color = color;
    }

    const CURRENT_VERSION_KEY = 'V1.3.0_alpha';
    function checkUpdatePopup() { if (!localStorage.getItem(CURRENT_VERSION_KEY)) document.getElementById('update-modal').style.display = 'flex'; }
    window.closeUpdateModal = function() {
        document.getElementById('update-modal').style.display = 'none';
        if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
        previewRequestId++; playPreview(currentSong, previewRequestId);
        localStorage.setItem(CURRENT_VERSION_KEY, 'true');
    };

    let isCalibrating = false;
    let calibTapHistory = [], calibNextBeatTime = 0, calibIntervalId;
    const CALIB_BPM = 100, CALIB_INTERVAL = 60 / CALIB_BPM, TOTAL_TAPS_NEEDED = 8;
    function startCalibration() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') audioCtx.resume();
        isCalibrating = true; calibTapHistory = [];
        document.getElementById('calibration-overlay').style.display = 'flex';
        document.getElementById('calib-step-1').style.display = 'block';
        document.getElementById('calib-result').style.display = 'none';
        document.getElementById('calib-apply-btn').style.display = 'none';
        document.getElementById('calib-progress-bar').style.width = '0%';
        document.getElementById('calib-status').innerText = "Listen to the beat...";
        stopPreview();
        calibNextBeatTime = audioCtx.currentTime + 0.5;
        playCalibBeatLoop();
    }
    function stopCalibration() {
        isCalibrating = false; clearTimeout(calibIntervalId);
        document.getElementById('calibration-overlay').style.display = 'none';
        previewRequestId++; playPreview(currentSong, previewRequestId);
    }
    function playCalibBeatLoop() {
        if (!isCalibrating) return;
        const currentTime = audioCtx.currentTime;
        if (currentTime >= calibNextBeatTime - 0.05) {
            playCalibSound(calibNextBeatTime);
            const delay = Math.max(0, (calibNextBeatTime - currentTime) * 1000);
            setTimeout(() => {
                if(!isCalibrating) return;
                const circle = document.getElementById('calib-beat-circle');
                circle.classList.add('beat-active');
                setTimeout(() => circle.classList.remove('beat-active'), 100);
            }, delay);
            calibNextBeatTime += CALIB_INTERVAL;
        }
        calibIntervalId = setTimeout(playCalibBeatLoop, 20);
    }
    function playCalibSound(time) {
        const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.frequency.setValueAtTime(880, time); osc.type = 'triangle';
        gain.gain.setValueAtTime(0, time); gain.gain.linearRampToValueAtTime(0.5, time + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.001, time + 0.1);
        osc.start(time); osc.stop(time + 0.1);
    }
    function handleCalibInput() {
        if (!isCalibrating || calibTapHistory.length >= TOTAL_TAPS_NEEDED) return;
        const now = audioCtx.currentTime;
        const diffPrev = now - (calibNextBeatTime - CALIB_INTERVAL); const diffNext = calibNextBeatTime - now; 
        let offset = (now - ((diffPrev < diffNext) ? (calibNextBeatTime - CALIB_INTERVAL) : calibNextBeatTime)) * 1000;
        const circle = document.getElementById('calib-beat-circle');
        circle.classList.remove('beat-active'); void circle.offsetWidth; circle.classList.add('tap-feedback');
        setTimeout(() => circle.classList.remove('tap-feedback'), 100);
        calibTapHistory.push(offset);
        document.getElementById('calib-progress-bar').style.width = (calibTapHistory.length / TOTAL_TAPS_NEEDED * 100) + "%";
        document.getElementById('calib-status').innerText = `Recording... ${calibTapHistory.length}/${TOTAL_TAPS_NEEDED}`;
        if (calibTapHistory.length >= TOTAL_TAPS_NEEDED) finishCalibration();
    }
    function calculateAverage(arr) {
        if (arr.length > 4) { arr.sort((a,b) => a-b); arr = arr.slice(1, arr.length-1); }
        return Math.floor(arr.reduce((a, b) => a + b, 0) / arr.length);
    }
    function finishCalibration() {
        isCalibrating = false; clearTimeout(calibIntervalId);
        const finalOffset = calculateAverage(calibTapHistory);
        document.getElementById('calib-status').innerText = "Calculation Complete";
        document.getElementById('calib-result').style.display = 'block';
        document.getElementById('calib-result').innerText = `Recommended Offset: ${finalOffset} ms`;
        const applyBtn = document.getElementById('calib-apply-btn');
        applyBtn.style.display = 'inline-block'; applyBtn.dataset.offset = finalOffset;
    }
    function applyCalibration() {
        const val = parseInt(document.getElementById('calib-apply-btn').dataset.offset);
        userSettings.offset = val; document.getElementById('offset-input').value = val; saveSettings();
        alert(`Â∑≤Â∫îÁî®Âª∂Ëøü: ${val}ms`); stopCalibration();
    }
    window.addEventListener('keydown', e => { if (isCalibrating && (e.code === 'Space' || e.code.startsWith('Arrow') || e.code.startsWith('Key'))) handleCalibInput(); });
    document.getElementById('calibration-overlay').addEventListener('mousedown', (e) => { if(e.target.tagName !== 'BUTTON') handleCalibInput(); });
</script>
</body>
</html>